/**
 * Chrome Native Messaging Host 安装和管理
 *
 * 架构：
 * Chrome 扩展 ↔ Native Messaging ↔ Native Host ↔ Socket Server ↔ MCP Server ↔ Claude CLI
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import { spawn } from 'child_process';
import { fileURLToPath } from 'url';

// ES Module 兼容：获取当前文件目录
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// 常量定义 - 与官方保持一致
export const CHROME_EXTENSION_ID = 'fcoeoabgfenejglbffodgkkbkcdhcgfn';
export const NATIVE_HOST_NAME = 'com.anthropic.claude_code_browser_extension';
export const CHROME_INSTALL_URL = 'https://claude.ai/chrome';
export const CHROME_RECONNECT_URL = 'https://clau.de/chrome/reconnect';
export const CHROME_PERMISSIONS_URL = 'https://clau.de/chrome/permissions';

/**
 * 获取当前平台
 */
export function getPlatform(): 'macos' | 'linux' | 'windows' | 'wsl' | 'unknown' {
  const platform = os.platform();
  if (platform === 'darwin') return 'macos';
  if (platform === 'win32') return 'windows';
  if (platform === 'linux') {
    // 检查是否在 WSL 中
    try {
      const release = os.release().toLowerCase();
      if (release.includes('microsoft') || release.includes('wsl')) {
        return 'wsl';
      }
    } catch {}
    return 'linux';
  }
  return 'unknown';
}

/**
 * 获取 Chrome Native Messaging Hosts 目录路径
 */
export function getNativeHostsDirectory(): string | null {
  const platform = getPlatform();
  const homedir = os.homedir();

  switch (platform) {
    case 'macos':
      return path.join(homedir, 'Library', 'Application Support', 'Google', 'Chrome', 'NativeMessagingHosts');
    case 'linux':
      return path.join(homedir, '.config', 'google-chrome', 'NativeMessagingHosts');
    case 'windows': {
      const appData = process.env.APPDATA || path.join(homedir, 'AppData', 'Local');
      return path.join(appData, 'Claude Code', 'ChromeNativeHost');
    }
    case 'wsl':
    default:
      return null;
  }
}

/**
 * 获取 Claude 配置目录
 */
export function getClaudeConfigDir(): string {
  const homedir = os.homedir();
  return path.join(homedir, '.claude');
}

/**
 * 获取 Socket 路径
 */
export function getSocketPath(): string {
  const username = os.userInfo().username || process.env.USER || process.env.USERNAME || 'default';
  const socketName = `claude-mcp-browser-bridge-${username}`;

  if (os.platform() === 'win32') {
    return `\\\\.\\pipe\\${socketName}`;
  }
  return path.join(os.tmpdir(), socketName);
}

/**
 * 生成 Native Host Manifest
 */
export function generateNativeHostManifest(wrapperScriptPath: string): object {
  return {
    name: NATIVE_HOST_NAME,
    description: 'Claude Code Browser Extension Native Host',
    path: wrapperScriptPath,
    type: 'stdio',
    allowed_origins: [
      `chrome-extension://${CHROME_EXTENSION_ID}/`
    ]
  };
}

/**
 * 生成 Native Host Wrapper Script
 */
export function generateWrapperScript(command: string): string {
  const platform = getPlatform();

  if (platform === 'windows') {
    return `@echo off
REM Chrome native host wrapper script
REM Generated by Claude Code - do not edit manually
${command}
`;
  }

  return `#!/bin/bash
# Chrome native host wrapper script
# Generated by Claude Code - do not edit manually
exec ${command}
`;
}

/**
 * 安装 Native Host Wrapper Script
 */
export async function installWrapperScript(command: string): Promise<string> {
  const platform = getPlatform();
  const configDir = getClaudeConfigDir();
  const chromeDir = path.join(configDir, 'chrome');

  const scriptName = platform === 'windows' ? 'chrome-native-host.bat' : 'chrome-native-host';
  const scriptPath = path.join(chromeDir, scriptName);

  const scriptContent = generateWrapperScript(command);

  // 检查是否需要更新
  try {
    const existing = await fs.readFile(scriptPath, 'utf-8');
    if (existing === scriptContent) {
      return scriptPath;
    }
  } catch {}

  // 创建目录
  await fs.mkdir(chromeDir, { recursive: true });

  // 写入脚本
  await fs.writeFile(scriptPath, scriptContent);

  // 设置执行权限（非 Windows）
  if (platform !== 'windows') {
    await fs.chmod(scriptPath, 0o755);
  }

  console.log(`[Claude in Chrome] Created wrapper script: ${scriptPath}`);
  return scriptPath;
}

/**
 * 安装 Native Host Manifest
 */
export async function installNativeHostManifest(wrapperScriptPath: string): Promise<void> {
  const hostsDir = getNativeHostsDirectory();
  if (!hostsDir) {
    throw new Error('Claude in Chrome Native Host not supported on this platform');
  }

  const manifestPath = path.join(hostsDir, `${NATIVE_HOST_NAME}.json`);
  const manifest = generateNativeHostManifest(wrapperScriptPath);
  const manifestContent = JSON.stringify(manifest, null, 2);

  // 检查是否需要更新
  try {
    const existing = await fs.readFile(manifestPath, 'utf-8');
    if (existing === manifestContent) {
      return;
    }
  } catch {}

  // 创建目录
  await fs.mkdir(hostsDir, { recursive: true });

  // 写入 manifest
  await fs.writeFile(manifestPath, manifestContent);

  // Windows 需要注册表注册
  if (getPlatform() === 'windows') {
    await registerWindowsNativeHost(manifestPath);
  }

  console.log(`[Claude in Chrome] Installed native host manifest: ${manifestPath}`);
}

/**
 * Windows 注册表注册
 */
async function registerWindowsNativeHost(manifestPath: string): Promise<void> {
  const regKey = `HKCU\\Software\\Google\\Chrome\\NativeMessagingHosts\\${NATIVE_HOST_NAME}`;

  return new Promise((resolve, reject) => {
    const proc = spawn('reg', [
      'add', regKey,
      '/ve',
      '/t', 'REG_SZ',
      '/d', manifestPath,
      '/f'
    ]);

    proc.on('close', (code) => {
      if (code === 0) {
        console.log(`[Claude in Chrome] Registered in Windows registry: ${regKey}`);
        resolve();
      } else {
        console.log(`[Claude in Chrome] Failed to register in Windows registry`);
        resolve(); // 不抛错，继续执行
      }
    });

    proc.on('error', () => {
      resolve(); // 忽略错误
    });
  });
}

/**
 * 检测 Chrome 扩展是否已安装
 */
export async function isExtensionInstalled(): Promise<boolean> {
  const platform = getPlatform();
  const homedir = os.homedir();

  let chromeBasePath: string | null = null;

  switch (platform) {
    case 'macos':
      chromeBasePath = path.join(homedir, 'Library', 'Application Support', 'Google', 'Chrome');
      break;
    case 'windows':
      chromeBasePath = path.join(homedir, 'AppData', 'Local', 'Google', 'Chrome', 'User Data');
      break;
    case 'linux':
      chromeBasePath = path.join(homedir, '.config', 'google-chrome');
      break;
    default:
      return false;
  }

  if (!chromeBasePath) return false;

  try {
    await fs.access(chromeBasePath);
    const entries = await fs.readdir(chromeBasePath, { withFileTypes: true });

    // 查找所有 Chrome profile
    const profiles = entries
      .filter(e => e.isDirectory())
      .filter(e => e.name === 'Default' || e.name.startsWith('Profile '))
      .map(e => e.name);

    // 检查每个 profile 中是否有扩展
    for (const profile of profiles) {
      const extensionPath = path.join(chromeBasePath, profile, 'Extensions', CHROME_EXTENSION_ID);
      try {
        await fs.access(extensionPath);
        console.log(`[Claude in Chrome] Extension found in ${profile}`);
        return true;
      } catch {}
    }
  } catch {}

  return false;
}

/**
 * 完整安装 Native Host
 */
export async function setupChromeNativeHost(): Promise<{
  mcpConfig: Record<string, unknown>;
  allowedTools: string[];
  systemPrompt: string;
}> {
  // 构建启动命令
  const nodeExe = process.execPath;
  const cliPath = path.join(__dirname, '..', 'cli.js');
  const command = `"${nodeExe}" "${cliPath}" --chrome-native-host`;

  // 安装 wrapper script
  const wrapperPath = await installWrapperScript(command);

  // 安装 manifest
  await installNativeHostManifest(wrapperPath);

  // 检查扩展是否安装
  const extensionInstalled = await isExtensionInstalled();
  if (extensionInstalled) {
    console.log('[Claude in Chrome] Extension detected, opening reconnect page');
    // 可以选择打开重连页面
  }

  // 返回 MCP 配置
  return {
    mcpConfig: {
      'claude-in-chrome': {
        type: 'stdio',
        command: 'node',
        args: [cliPath, '--claude-in-chrome-mcp'],
        scope: 'dynamic'
      }
    },
    allowedTools: getMcpToolNames(),
    systemPrompt: CHROME_SYSTEM_PROMPT
  };
}

/**
 * 获取所有 MCP 工具名称
 */
export function getMcpToolNames(): string[] {
  return [
    'mcp__claude-in-chrome__javascript_tool',
    'mcp__claude-in-chrome__read_page',
    'mcp__claude-in-chrome__find',
    'mcp__claude-in-chrome__form_input',
    'mcp__claude-in-chrome__computer',
    'mcp__claude-in-chrome__navigate',
    'mcp__claude-in-chrome__resize_window',
    'mcp__claude-in-chrome__gif_creator',
    'mcp__claude-in-chrome__upload_image',
    'mcp__claude-in-chrome__get_page_text',
    'mcp__claude-in-chrome__tabs_context_mcp',
    'mcp__claude-in-chrome__tabs_create_mcp',
    'mcp__claude-in-chrome__update_plan',
    'mcp__claude-in-chrome__read_console_messages',
    'mcp__claude-in-chrome__read_network_requests',
    'mcp__claude-in-chrome__shortcuts_list',
    'mcp__claude-in-chrome__shortcuts_execute'
  ];
}

/**
 * Chrome 浏览器自动化系统提示词
 */
export const CHROME_SYSTEM_PROMPT = `
# Claude in Chrome browser automation

You have access to browser automation tools (mcp__claude-in-chrome__*) for interacting with web pages in Chrome. Follow these guidelines for effective browser automation.

## GIF recording

When performing multi-step browser interactions that the user may want to review or share, use mcp__claude-in-chrome__gif_creator to record them.

You must ALWAYS:
* Capture extra frames before and after taking actions to ensure smooth playback
* Name the file meaningfully to help the user identify it later (e.g., "login_process.gif")

## Console log debugging

You can use mcp__claude-in-chrome__read_console_messages to read console output. Console output may be verbose. If you are looking for specific log entries, use the 'pattern' parameter with a regex-compatible pattern. This filters results efficiently and avoids overwhelming output. For example, use pattern: "[MyApp]" to filter for application-specific logs rather than reading all console output.

## Alerts and dialogs

Do not trigger JavaScript alerts, confirms, prompts, or browser modal dialogs through your actions. These browser dialogs block all further browser events and will prevent the extension from receiving any subsequent commands. Instead, when possible, use console.log for debugging and then use the mcp__claude-in-chrome__read_console_messages tool to read those log messages. If a page has dialog-triggering elements:
1. Avoid clicking buttons or links that may trigger alerts (e.g., "Delete" buttons with confirmation dialogs)
2. If you must interact with such elements, warn the user first that this may interrupt the session
3. Use mcp__claude-in-chrome__javascript_tool to check for and dismiss any existing dialogs before proceeding

If you accidentally trigger a dialog and lose responsiveness, inform the user they need to manually dismiss it in the browser.

## Avoid rabbit holes and loops

When using browser automation tools, stay focused on the specific task. If you encounter any of the following, stop and ask the user for guidance:
- Unexpected complexity or tangential browser exploration
- Browser tool calls failing or returning errors after 2-3 attempts
- No response from the browser extension
- Page elements not responding to clicks or input
- Pages not loading or timing out
- Unable to complete the browser task despite multiple approaches

Explain what you attempted, what went wrong, and ask how the user would like to proceed. Do not keep retrying the same failing browser action or explore unrelated pages without checking in first.

## Tab context and session startup

IMPORTANT: At the start of each browser automation session, call mcp__claude-in-chrome__tabs_context_mcp first to get information about the user's current browser tabs. Use this context to understand what the user might want to work with before creating new tabs.

Never reuse tab IDs from a previous/other session. Follow these guidelines:
1. Only reuse an existing tab if the user explicitly asks to work with it
2. Otherwise, create a new tab with mcp__claude-in-chrome__tabs_create_mcp
3. If a tool returns an error indicating the tab doesn't exist or is invalid, call tabs_context_mcp to get fresh tab IDs
4. When a tab is closed by the user or a navigation error occurs, call tabs_context_mcp to see what tabs are available
`;
